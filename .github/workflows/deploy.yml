name: ğŸš€ Application Deployment (CD)


on:
  workflow_run:
    workflows: ["ğŸ³ Backend CI Pipeline", "ğŸ–¥ï¸Terraform CI/CD Pipeline"]
    types: [completed]
    branches: [main, develop]

  # Trigger manual para testes
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente para deploy'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - prod

env:
  DOCKER_IMAGE_NAME: 1234samue/desafio-devops-api
  AWS_REGION: 'us-east-1'

jobs:
  # ========================================
  # ETAPA 1: VERIFICAÃ‡ÃƒO DE PRÃ‰-REQUISITOS
  # ========================================
  check-prerequisites:
    name: 'ğŸ” Check Prerequisites'
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ“‹ Read Version and Set Docker Tag
      id: version
      run: |
        echo "ğŸ“‹ Reading version from VERSION file..."
        VERSION=$(cat VERSION | tr -d '[:space:]')
        echo "ğŸ“¦ Version read: $VERSION"
        echo "DOCKER_TAG=$VERSION" >> $GITHUB_ENV
        echo "docker_tag=$VERSION" >> $GITHUB_OUTPUT
        echo "âœ… DOCKER_TAG set to: $VERSION"

    - name: ğŸ” Check Workflow Status
      if: github.event_name == 'workflow_run'
      run: |
        echo "ğŸ” Verificando status do workflow que disparou o deploy..."
        echo "Workflow: ${{ github.event.workflow_run.name }}"
        echo "Status: ${{ github.event.workflow_run.conclusion }}"
        echo "Branch: ${{ github.event.workflow_run.head_branch }}"
        
        if [[ "${{ github.event.workflow_run.conclusion }}" != "success" ]]; then
          echo "âŒ Workflow nÃ£o foi bem-sucedido. Deploy cancelado."
          exit 1
        fi
        
        echo "âœ… Workflow bem-sucedido. Continuando com o deploy..."

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'
  
    - name: ğŸ” Detect Environment
      id: env
      run: |
          # Detectar ambiente baseado na branch que disparou o workflow ou input manual
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            echo "ğŸŒ Environment detected from manual input: $ENVIRONMENT"
          elif [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
            ENVIRONMENT="prod"
            echo "ğŸŒ Environment detected: PROD"
          else
            ENVIRONMENT="dev"
            echo "ğŸŒ Environment detected: DEV"
          fi
          
          # Definir NODE_ENV baseado no ambiente
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            NODE_ENV="production"
          else
            NODE_ENV="development"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "node_env=$NODE_ENV" >> $GITHUB_OUTPUT
          
          echo "ğŸŒ Environment: $ENVIRONMENT"
          echo "ğŸ”§ NODE_ENV: $NODE_ENV"
          
          # Configurar backend para o ambiente detectado
          echo "ğŸ—‚ï¸ Configurando backend para ambiente: $ENVIRONMENT"
          cd terraform
          sed -i "s|key     = \"terraform/environments/[^\"]*\"|key     = \"terraform/environments/$ENVIRONMENT/terraform.tfstate\"|g" backend.tf

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init
    - name: ğŸ“Š Get Infrastructure Info
      working-directory: ./terraform
      id: infra
      run: |
        echo "ğŸ” Getting infrastructure info for ${{ steps.env.outputs.environment }} environment..."
        echo "instance_ip=$(terraform output -raw elastic_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
        echo "security_group_id=$(terraform output -raw security_group_id)" >> $GITHUB_OUTPUT

    - name: ğŸ“‹ Display Infrastructure Info
      run: |
        echo "ğŸŒ Environment: ${{ steps.env.outputs.environment }}"
        echo "ğŸ”§ NODE_ENV: ${{ steps.env.outputs.node_env }}"
        echo "ğŸŒ Instance Public IP: ${{ steps.infra.outputs.instance_ip }}"
        echo "ğŸ†” Instance ID: ${{ steps.infra.outputs.instance_id }}"
        echo "ğŸ›¡ï¸ Security Group ID: ${{ steps.infra.outputs.security_group_id }}"

    - name: ğŸ” Verify Instance Status
      run: |
        echo "ğŸ” Verificando status da instÃ¢ncia no ambiente ${{ steps.env.outputs.environment }}..."
        aws ec2 describe-instances \
          --instance-ids ${{ steps.infra.outputs.instance_id }} \
          --query 'Reservations[0].Instances[0].State.Name' \
          --output text
        
        # Aguardar instÃ¢ncia estar running
        echo "â³ Aguardando instÃ¢ncia estar pronta..."
        aws ec2 wait instance-running --instance-ids ${{ steps.infra.outputs.instance_id }}
        echo "âœ… InstÃ¢ncia estÃ¡ running!"

  # ========================================
  # ETAPA 2: DEPLOY DA APLICAÃ‡ÃƒO
  # ========================================
  deploy-application:
    name: 'ğŸš€ Deploy Application'
    runs-on: ubuntu-latest
    needs: check-prerequisites
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ“‹ Read Version and Set Docker Tag
      id: version
      run: |
        echo "ğŸ“‹ Reading version from VERSION file..."
        VERSION=$(cat VERSION | tr -d '[:space:]')
        echo "ğŸ“¦ Version read: $VERSION"
        echo "DOCKER_TAG=$VERSION" >> $GITHUB_ENV
        echo "docker_tag=$VERSION" >> $GITHUB_OUTPUT
        echo "âœ… DOCKER_TAG set to: $VERSION"

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'
    - name: ğŸ” Detect Environment
      id: env
      run: |
          # Detectar ambiente baseado na branch que disparou o workflow ou input manual
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            echo "ğŸŒ Environment detected from manual input: $ENVIRONMENT"
          elif [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
            ENVIRONMENT="prod"
            echo "ğŸŒ Environment detected: PROD"
          else
            ENVIRONMENT="dev"
            echo "ğŸŒ Environment detected: DEV"
          fi
          
          # Definir NODE_ENV baseado no ambiente
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            NODE_ENV="production"
          else
            NODE_ENV="development"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "node_env=$NODE_ENV" >> $GITHUB_OUTPUT
          
          echo "ğŸŒ Environment: $ENVIRONMENT"
          echo "ğŸ”§ NODE_ENV: $NODE_ENV"
          
          # Configurar backend para o ambiente detectado
          echo "ğŸ—‚ï¸ Configurando backend para ambiente: $ENVIRONMENT"
          cd terraform
          sed -i "s|key     = \"terraform/environments/[^\"]*\"|key     = \"terraform/environments/$ENVIRONMENT/terraform.tfstate\"|g" backend.tf
    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init
    - name: ğŸ“Š Set Instance IP
      id: infra
      working-directory: ./terraform
      run: |
        echo "ğŸ” Definindo IP da instÃ¢ncia para deploy no ambiente ${{ steps.env.outputs.environment }}..."
        INSTANCE_IP=$(terraform output -raw elastic_ip)
        echo "âœ… IP da instÃ¢ncia definido: $INSTANCE_IP"
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: ğŸ” Setup SSH Connection
      run: |
        echo "ğŸ” Iniciando configuraÃ§Ã£o SSH..."
        
        # Criar diretÃ³rio .ssh
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Verificar se o secret SSH_PRIVATE_KEY existe
        if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
          echo "âŒ ERRO: SSH_PRIVATE_KEY secret nÃ£o estÃ¡ configurado!"
          echo "ğŸ’¡ Configure o secret SSH_PRIVATE_KEY no GitHub:"
          echo "   Settings > Secrets and variables > Actions > New repository secret"
          echo "   Name: SSH_PRIVATE_KEY"
          echo "   Value: ConteÃºdo da sua chave privada SSH"
          exit 1
        fi
        
        # Configurar chave privada
        echo "ğŸ”‘ Configurando chave privada SSH..."
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        # Verificar formato da chave
        if ! ssh-keygen -l -f ~/.ssh/id_rsa > /dev/null 2>&1; then
          echo "âŒ ERRO: Formato da chave SSH invÃ¡lido!"
          echo "ğŸ’¡ Verifique se a chave estÃ¡ no formato correto (incluindo BEGIN e END lines)"
          exit 1
        fi
        
        echo "âœ… Chave SSH configurada com sucesso"
        
        # Configurar known_hosts
        echo "ğŸ” Configurando known_hosts..."
        ssh-keyscan -H ${{ steps.infra.outputs.instance_ip }} >> ~/.ssh/known_hosts 2>/dev/null || {
          echo "âš ï¸ Aviso: NÃ£o foi possÃ­vel adicionar host key para ${{ steps.infra.outputs.instance_ip }}"
        }
                
        # Testar conexÃ£o SSH com mais detalhes
        echo "ğŸ” Testando conexÃ£o SSH..."
        ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -v ubuntu@${{ steps.infra.outputs.instance_ip }} "echo 'SSH connection successful'" 2>&1 || {
          echo "âŒ ERRO: Falha na conexÃ£o SSH"
          echo "ğŸ’¡ PossÃ­veis causas:"
          echo "   - Chave SSH incorreta"
          echo "   - InstÃ¢ncia nÃ£o estÃ¡ pronta"
          echo "   - Security group nÃ£o permite SSH (porta 22)"
          echo "   - UsuÃ¡rio 'ubuntu' nÃ£o existe na instÃ¢ncia"
          echo "ğŸ” Verificando se a porta 22 estÃ¡ aberta..."
          nc -z -w5 ${{ steps.infra.outputs.instance_ip }} 22 || echo "âŒ Porta 22 nÃ£o estÃ¡ acessÃ­vel"
          exit 1
        }
        
        echo "âœ… ConexÃ£o SSH estabelecida com sucesso!"

    - name: ğŸ³ Deploy Docker Application
      run: |
        echo "ğŸš€ Iniciando deploy da aplicaÃ§Ã£o no ambiente ${{ steps.env.outputs.environment }}..."
        
        # Comandos para deploy via SSH
        ssh ubuntu@${{ steps.infra.outputs.instance_ip }} << EOF
          echo "ğŸŒ Environment: ${{ steps.env.outputs.environment }}"
          echo "ğŸ”§ NODE_ENV: ${{ steps.env.outputs.node_env }}"
          echo "ğŸ“ Navegando para diretÃ³rio da aplicaÃ§Ã£o..."
          cd /opt/app/desafio-devops
          git pull
          echo "âœ… Pull realizado com sucesso"


          cd /opt/app/desafio-devops/backend
          
          echo "ğŸ“ Atualizando docker-compose.prod.yml com versÃ£o ${{ env.DOCKER_TAG }}..."
          
          # Backup do arquivo original
          cp docker-compose.prod.yml docker-compose.prod.yml.backup
          
          # Atualizar a imagem com a nova versÃ£o
          sed -i "s|image:.*1234samue/desafio-devops-api:.*|image: docker.io/1234samue/desafio-devops-api:${{ env.DOCKER_TAG }}|g" docker-compose.prod.yml
          
          # Atualizar a versÃ£o no environment
          sed -i "s|VERSION:.*|VERSION: ${{ env.DOCKER_TAG }}|g" docker-compose.prod.yml
          
          # Definir NODE_ENV baseado no ambiente detectado
          sed -i "s|NODE_ENV:.*|NODE_ENV: ${{ steps.env.outputs.node_env }}|g" docker-compose.prod.yml
          
          echo "âœ… docker-compose.prod.yml atualizado com versÃ£o ${{ env.DOCKER_TAG }} e NODE_ENV: ${{ steps.env.outputs.node_env }}"
          
          echo "ğŸ”„ Parando containers existentes..."
          docker compose -f docker-compose.prod.yml down || true
          
          echo "ğŸ§¹ Limpando imagens antigas..."
          docker system prune -f
          
          echo "ğŸ“¥ Baixando nova imagem..."
          docker pull ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}
          
          echo "ğŸš€ Iniciando aplicaÃ§Ã£o..."
          docker compose -f docker-compose.prod.yml up -d
          
          echo "â³ Aguardando aplicaÃ§Ã£o inicializar..."
          sleep 30
          
          echo "ğŸ” Verificando status dos containers..."
          docker compose -f docker-compose.prod.yml ps
          
          echo "ğŸ“Š Verificando logs da aplicaÃ§Ã£o..."
          docker compose -f docker-compose.prod.yml logs --tail=20
        EOF

  # ========================================
  # ETAPA 3: TESTES PÃ“S-DEPLOY
  # ========================================
  post-deploy-tests:
    name: 'ğŸ§ª Post-Deploy Tests'
    runs-on: ubuntu-latest
    needs: deploy-application
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'
    - name: ğŸ” Detect Environment
      id: env
      run: |
          # Detectar ambiente baseado na branch que disparou o workflow ou input manual
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            echo "ğŸŒ Environment detected from manual input: $ENVIRONMENT"
          elif [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
            ENVIRONMENT="prod"
            echo "ğŸŒ Environment detected: PROD"
          else
            ENVIRONMENT="dev"
            echo "ğŸŒ Environment detected: DEV"
          fi
          
          # Definir NODE_ENV baseado no ambiente
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            NODE_ENV="production"
          else
            NODE_ENV="development"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "node_env=$NODE_ENV" >> $GITHUB_OUTPUT
          
          echo "ğŸŒ Environment: $ENVIRONMENT"
          echo "ğŸ”§ NODE_ENV: $NODE_ENV"
          
          # Configurar backend para o ambiente detectado
          echo "ğŸ—‚ï¸ Configurando backend para ambiente: $ENVIRONMENT"
          cd terraform
          sed -i "s|key     = \"terraform/environments/[^\"]*\"|key     = \"terraform/environments/$ENVIRONMENT/terraform.tfstate\"|g" backend.tf

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init
    - name: ğŸ“Š Set Instance IP for Tests
      id: infra
      working-directory: ./terraform
      run: |
        echo "ğŸ” Definindo IP da instÃ¢ncia para testes no ambiente ${{ steps.env.outputs.environment }}..."
        INSTANCE_IP=$(terraform output -raw elastic_ip)
        echo "âœ… IP da instÃ¢ncia definido: $INSTANCE_IP"
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: ğŸ” Health Check
      run: |
        echo "ğŸ” Verificando health check da aplicaÃ§Ã£o no ambiente ${{ steps.env.outputs.environment }}..."
        
        # Aguardar aplicaÃ§Ã£o estar pronta
        for i in {1..30}; do
          echo "â³ Tentativa $i/30 - Verificando health check..."
          if curl -f http://${{ steps.infra.outputs.instance_ip }}:3000/health > /dev/null 2>&1; then
            echo "âœ… Health check passou!"
            break
          fi
          sleep 10
        done
        
        # Teste final
        if ! curl -f http://${{ steps.infra.outputs.instance_ip }}:3000/health; then
          echo "âŒ Health check falhou apÃ³s 30 tentativas"
          exit 1
        fi

    - name: ğŸ§ª API Tests
      run: |
        echo "ğŸ§ª Executando testes da API no ambiente ${{ steps.env.outputs.environment }}..."
        
        # Teste de criaÃ§Ã£o de usuÃ¡rio
        echo "ğŸ“ Testando criaÃ§Ã£o de usuÃ¡rio..."
        curl -X POST http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -H "Content-Type: application/json" \
          -d '{"name":"Test User","email":"test@example.com","password":"123456","age":25}' \
          -w "\nStatus: %{http_code}\n"
        
        # Teste de listagem de usuÃ¡rios
        echo "ğŸ“‹ Testando listagem de usuÃ¡rios..."
        curl -X GET http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -w "\nStatus: %{http_code}\n"
        
        # Teste de health check
        echo "ğŸ’š Testando health check..."
        curl -X GET http://${{ steps.infra.outputs.instance_ip }}:3000/health \
          -w "\nStatus: %{http_code}\n"

    - name: ğŸ” Security Tests
      run: |
        echo "ğŸ” Executando testes de seguranÃ§a no ambiente ${{ steps.env.outputs.environment }}..."
        
        # Teste de headers de seguranÃ§a
        echo "ğŸ›¡ï¸ Verificando headers de seguranÃ§a..."
        curl -I http://${{ steps.infra.outputs.instance_ip }}:3000/health
        
        # Teste de CORS
        echo "ğŸŒ Verificando CORS..."
        curl -H "Origin: https://malicious-site.com" \
          -H "Access-Control-Request-Method: POST" \
          -H "Access-Control-Request-Headers: Content-Type" \
          -X OPTIONS http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -v

  # ========================================
  # ETAPA 4: MONITORAMENTO E NOTIFICAÃ‡ÃƒO
  # ========================================
  monitoring:
    name: 'ğŸ“Š Monitoring & Notification'
    runs-on: ubuntu-latest
    needs: [deploy-application, post-deploy-tests]
    if: always()
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'
    - name: ğŸ” Detect Environment
      id: env
      run: |
          # Detectar ambiente baseado na branch que disparou o workflow ou input manual
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            echo "ğŸŒ Environment detected from manual input: $ENVIRONMENT"
          elif [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
            ENVIRONMENT="prod"
            echo "ğŸŒ Environment detected: PROD"
          else
            ENVIRONMENT="dev"
            echo "ğŸŒ Environment detected: DEV"
          fi
          
          # Definir NODE_ENV baseado no ambiente
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            NODE_ENV="production"
          else
            NODE_ENV="development"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "node_env=$NODE_ENV" >> $GITHUB_OUTPUT
          
          echo "ğŸŒ Environment: $ENVIRONMENT"
          echo "ğŸ”§ NODE_ENV: $NODE_ENV"
          
          # Configurar backend para o ambiente detectado
          echo "ğŸ—‚ï¸ Configurando backend para ambiente: $ENVIRONMENT"
          cd terraform
          sed -i "s|key     = \"terraform/environments/[^\"]*\"|key     = \"terraform/environments/$ENVIRONMENT/terraform.tfstate\"|g" backend.tf
    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init
    - name: ğŸ“Š Get Infrastructure Info
      working-directory: ./terraform
      id: infra
      run: |
        echo "ğŸ” Getting infrastructure info for ${{ steps.env.outputs.environment }} environment..."
        echo "instance_ip=$(terraform output -raw elastic_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT

    - name: ğŸ“ˆ System Monitoring
      run: |
        echo "ğŸ“ˆ Verificando mÃ©tricas do sistema no ambiente ${{ steps.env.outputs.environment }}..."
        
        # Verificar uso de CPU e memÃ³ria da instÃ¢ncia
        aws cloudwatch get-metric-statistics \
          --namespace AWS/EC2 \
          --metric-name CPUUtilization \
          --dimensions Name=InstanceId,Value=${{ steps.infra.outputs.instance_id }} \
          --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \
          --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
          --period 300 \
          --statistics Average

    - name: ğŸ“‹ Deployment Summary
      run: |
        echo "ğŸ‰ DEPLOYMENT SUMMARY"
        echo "===================="
        echo "ğŸŒ Environment: ${{ steps.env.outputs.environment }}"
        echo "ğŸ”§ NODE_ENV: ${{ steps.env.outputs.node_env }}"
        echo "âœ… Application deployed successfully!"
        echo "ğŸŒ Public URL: http://${{ steps.infra.outputs.instance_ip }}:3000"
        echo "ğŸ†” Instance ID: ${{ steps.infra.outputs.instance_id }}"
        echo "ğŸ³ Docker Image: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}"
        echo "ğŸ“… Deployed at: $(date)"
        echo "ğŸ”— Health Check: http://${{ steps.infra.outputs.instance_ip }}:3000/health"
        echo "ğŸ“Š API Endpoints:"
        echo "   - GET /health"
        echo "   - GET /users"
        echo "   - POST /users"
        echo "   - GET /users/:id"
        echo "   - PUT /users/:id"
        echo "   - DELETE /users/:id"

    - name: ğŸ“¢ Success Notification
      if: success()
      run: |
        echo "ğŸ‰ DEPLOYMENT SUCCESSFUL!"
        echo "========================="
        echo "ğŸŒ Environment: ${{ steps.env.outputs.environment }}"
        echo "ğŸ”§ NODE_ENV: ${{ steps.env.outputs.node_env }}"
        echo "âœ… All tests passed"
        echo "âœ… Application is running"
        echo "âœ… Security checks passed"
        echo "ğŸŒ Access your application at: http://${{ steps.infra.outputs.instance_ip }}:3000"

    - name: ğŸš¨ Failure Notification
      if: failure()
      run: |
        echo "âŒ DEPLOYMENT FAILED!"
        echo "====================="
        echo "ğŸŒ Environment: ${{ steps.env.outputs.environment }}"
        echo "ğŸ”§ NODE_ENV: ${{ steps.env.outputs.node_env }}"
        echo "âŒ One or more steps failed"
        echo "ğŸ” Check the logs above for details"
        echo "ğŸ”„ Manual intervention may be required"

    # ========================================
    # NOTIFICAÃ‡Ã•ES DO SLACK
    # ========================================
    - name: ğŸ‰ Notificar Sucesso do Deploy
      if: success()
      uses: samuelBarreto/Action-Slack@main
      with:
        webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
        message: |
          ğŸš€ **Deploy Realizado com Sucesso!**
          
          **Ambiente:** ${{ steps.env.outputs.environment }}
          **VersÃ£o:** ${{ env.DOCKER_TAG }}
          **URL:** http://${{ steps.infra.outputs.instance_ip }}:3000
          **RepositÃ³rio:** ${{ github.repository }}
          **Branch:** ${{ github.ref_name }}
          **Autor:** ${{ github.actor }}
          
          âœ… AplicaÃ§Ã£o estÃ¡ rodando e saudÃ¡vel!
        channel: '#deployments'
        username: 'Deploy Bot'
        icon-emoji: ':rocket:'

    - name: âŒ Notificar Falha do Deploy
      if: failure()
      uses: samuelBarreto/Action-Slack@main
      with:
        webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
        message: |
          ğŸš¨ **Deploy Falhou!**
          
          **Ambiente:** ${{ steps.env.outputs.environment }}
          **VersÃ£o:** ${{ env.DOCKER_TAG }}
          **RepositÃ³rio:** ${{ github.repository }}
          **Branch:** ${{ github.ref_name }}
          **Autor:** ${{ github.actor }}
          
          âŒ Verifique os logs do workflow para mais detalhes.
          ğŸ”— [Ver Workflow](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
        channel: '#alerts'
        username: 'Deploy Bot'
        icon-emoji: ':warning:' 