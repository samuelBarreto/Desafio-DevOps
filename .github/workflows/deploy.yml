name: üöÄ Application Deployment (CD)

on:
  workflow_run:
    workflows: ["Backend CI Pipeline", "Terraform CI/CD Pipeline"]
    types: [completed]
    branches: [main]

env:
  DOCKER_IMAGE_NAME: 1234samue/desafio-devops-api
  DOCKER_TAG: 0.0.1
  AWS_REGION: 'us-east-1'

jobs:
  # ========================================
  # ETAPA 1: VERIFICAR SE AMBOS OS WORKFLOWS TERMINARAM
  # ========================================
  check-workflows:
    name: 'üîç Check Both Workflows Status'
    runs-on: ubuntu-latest
    
    steps:
    - name: üìã Check Deployment Lock
      id: check-lock
      run: |
        echo "üîí Verificando se j√° h√° um deploy em andamento..."
        
        # Verificar se h√° algum run deste workflow em andamento
        CURRENT_RUN_ID="${{ github.run_id }}"
        RUNNING_DEPLOYS=$(gh run list --workflow="üöÄ Application Deployment (CD)" --status=in_progress --json id,status --jq '.[] | select(.id != '$CURRENT_RUN_ID') | .id' | wc -l)
        
        if [ "$RUNNING_DEPLOYS" -gt 0 ]; then
          echo "‚ö†Ô∏è J√° h√° um deploy em andamento. Aguardando..."
          echo "deploy_in_progress=true" >> $GITHUB_OUTPUT
        else
          echo "‚úÖ Nenhum deploy em andamento. Prosseguindo..."
          echo "deploy_in_progress=false" >> $GITHUB_OUTPUT
        fi

    - name: üìã Check Workflow Status
      id: check-status
      if: steps.check-lock.outputs.deploy_in_progress == 'false'
      run: |
        echo "üîç Verificando status dos workflows..."
        
        # Obter informa√ß√µes do workflow que acionou este pipeline
        TRIGGERING_WORKFLOW="${{ github.event.workflow.name }}"
        TRIGGERING_RUN_ID="${{ github.event.workflow_run.id }}"
        
        echo "üìã Workflow acionador: $TRIGGERING_WORKFLOW"
        echo "üÜî Run ID: $TRIGGERING_RUN_ID"
        
        # Verificar se o workflow acionador foi bem-sucedido
        if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
          echo "‚ùå Workflow acionador n√£o foi bem-sucedido: ${{ github.event.workflow_run.conclusion }}"
          exit 1
        fi
        
        echo "‚úÖ Workflow acionador foi bem-sucedido"
        
        # Fun√ß√£o para verificar se um workflow terminou com sucesso recentemente
        check_workflow_success() {
          local workflow_name="$1"
          local max_age_minutes=10  # Considerar apenas runs dos √∫ltimos 10 minutos
          
          echo "üîç Verificando $workflow_name..."
          
          # Obter runs recentes do workflow
          local runs=$(gh run list --workflow="$workflow_name" --limit=10 --json conclusion,createdAt,id)
          
          # Verificar se h√° algum run bem-sucedido recente
          local success_run=$(echo "$runs" | jq -r '.[] | select(.conclusion == "success") | select((now - (.createdAt | fromdateiso8601)) < ('$max_age_minutes' * 60)) | .id' | head -1)
          
          if [ -n "$success_run" ] && [ "$success_run" != "null" ]; then
            echo "‚úÖ $workflow_name: Run $success_run foi bem-sucedido recentemente"
            return 0
          else
            echo "‚ùå $workflow_name: Nenhum run bem-sucedido recente encontrado"
            return 1
          fi
        }
        
        # Verificar ambos os workflows
        BACKEND_SUCCESS=false
        TERRAFORM_SUCCESS=false
        
        if check_workflow_success "Backend CI Pipeline"; then
          BACKEND_SUCCESS=true
        fi
        
        if check_workflow_success "Terraform CI/CD Pipeline"; then
          TERRAFORM_SUCCESS=true
        fi
        
        echo "üìä Status dos workflows:"
        echo "   Backend CI: $BACKEND_SUCCESS"
        echo "   Terraform: $TERRAFORM_SUCCESS"
        
        # Verificar se ambos terminaram com sucesso
        if [ "$BACKEND_SUCCESS" = true ] && [ "$TERRAFORM_SUCCESS" = true ]; then
          echo "‚úÖ Ambos os workflows terminaram com sucesso!"
          echo "ready=true" >> $GITHUB_OUTPUT
        else
          echo "‚è≥ Aguardando ambos os workflows terminarem..."
          echo "   Backend CI: $BACKEND_SUCCESS"
          echo "   Terraform: $TERRAFORM_SUCCESS"
          echo "ready=false" >> $GITHUB_OUTPUT
        fi

  # ========================================
  # ETAPA 2: AGUARDAR DEPLOY ANTERIOR (SE NECESS√ÅRIO)
  # ========================================
  wait-for-deploy:
    name: '‚è≥ Wait for Previous Deploy'
    runs-on: ubuntu-latest
    needs: check-workflows
    if: needs.check-workflows.outputs.deploy_in_progress == 'true'
    
    steps:
    - name: üìã Wait for Deployment
      run: |
        echo "‚è≥ Aguardando deploy anterior terminar..."
        echo "üîç Verificando status a cada 30 segundos..."
        
        for i in {1..20}; do
          echo "‚è≥ Tentativa $i/20 - Verificando se h√° deploy em andamento..."
          
          # Verificar se ainda h√° deploy em andamento
          RUNNING_DEPLOYS=$(gh run list --workflow="üöÄ Application Deployment (CD)" --status=in_progress --json id,status --jq '.[] | select(.id != '${{ github.run_id }}') | .id' | wc -l)
          
          if [ "$RUNNING_DEPLOYS" -eq 0 ]; then
            echo "‚úÖ Nenhum deploy em andamento. Prosseguindo..."
            break
          fi
          
          echo "‚è≥ Ainda h√° $RUNNING_DEPLOYS deploy(s) em andamento. Aguardando 30s..."
          sleep 30
        done
        
        echo "‚úÖ Aguardamento conclu√≠do!"

  # ========================================
  # ETAPA 3: VERIFICA√á√ÉO DE PR√â-REQUISITOS
  # ========================================
  check-prerequisites:
    name: 'üîç Check Prerequisites'
    runs-on: ubuntu-latest
    needs: [check-workflows, wait-for-deploy]
    if: needs.check-workflows.outputs.ready == 'true' && (needs.check-workflows.outputs.deploy_in_progress == 'false' || needs.wait-for-deploy.result == 'success')
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4

    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üèóÔ∏è Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: üöÄ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: üìä Get Infrastructure Info
      working-directory: ./terraform
      id: infra
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
        echo "security_group_id=$(terraform output -raw security_group_id)" >> $GITHUB_OUTPUT

    - name: üìã Display Infrastructure Info
      run: |
        echo "üåê Instance Public IP: ${{ steps.infra.outputs.instance_ip }}"
        echo "üÜî Instance ID: ${{ steps.infra.outputs.instance_id }}"
        echo "üõ°Ô∏è Security Group ID: ${{ steps.infra.outputs.security_group_id }}"

    - name: üîç Verify Instance Status
      run: |
        echo "üîç Verificando status da inst√¢ncia..."
        aws ec2 describe-instances \
          --instance-ids ${{ steps.infra.outputs.instance_id }} \
          --query 'Reservations[0].Instances[0].State.Name' \
          --output text
        
        # Aguardar inst√¢ncia estar running
        echo "‚è≥ Aguardando inst√¢ncia estar pronta..."
        aws ec2 wait instance-running --instance-ids ${{ steps.infra.outputs.instance_id }}
        echo "‚úÖ Inst√¢ncia est√° running!"

  # ========================================
  # ETAPA 4: DEPLOY DA APLICA√á√ÉO
  # ========================================
  deploy-application:
    name: 'üöÄ Deploy Application'
    runs-on: ubuntu-latest
    needs: check-prerequisites
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4

    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üèóÔ∏è Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: üöÄ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: üìä Get Instance IP
      working-directory: ./terraform
      id: infra
      run: |
        echo "üîç Obtendo IP da inst√¢ncia..."
        
        # Verificar se o Terraform est√° inicializado
        if [ ! -f ".terraform/terraform.tfstate" ]; then
          echo "‚ùå ERRO: Terraform n√£o est√° inicializado!"
          exit 1
        fi
        
        # Tentar obter o IP da inst√¢ncia
        INSTANCE_IP=$(terraform output -raw instance_public_ip 2>/dev/null) || {
          echo "‚ùå ERRO: N√£o foi poss√≠vel obter o IP da inst√¢ncia!"
          echo "üí° Poss√≠veis causas:"
          echo "   - Infraestrutura n√£o foi aplicada"
          echo "   - Output 'instance_public_ip' n√£o existe"
          echo "   - Estado do Terraform corrompido"
          echo ""
          echo "üîç Verificando outputs dispon√≠veis..."
          terraform output || echo "‚ùå Nenhum output dispon√≠vel"
          exit 1
        }
        
        # Validar se o IP n√£o est√° vazio
        if [ -z "$INSTANCE_IP" ]; then
          echo "‚ùå ERRO: IP da inst√¢ncia est√° vazio!"
          exit 1
        fi
        
        # Validar formato do IP
        if ! echo "$INSTANCE_IP" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' > /dev/null; then
          echo "‚ùå ERRO: Formato de IP inv√°lido: $INSTANCE_IP"
          exit 1
        fi
        
        echo "‚úÖ IP da inst√¢ncia obtido: $INSTANCE_IP"
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: üîê Setup SSH Connection
      run: |
        echo "üîç Iniciando configura√ß√£o SSH..."
        
        # Criar diret√≥rio .ssh
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Verificar se o secret SSH_PRIVATE_KEY existe
        if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
          echo "‚ùå ERRO: SSH_PRIVATE_KEY secret n√£o est√° configurado!"
          echo "üí° Configure o secret SSH_PRIVATE_KEY no GitHub:"
          echo "   Settings > Secrets and variables > Actions > New repository secret"
          echo "   Name: SSH_PRIVATE_KEY"
          echo "   Value: Conte√∫do da sua chave privada SSH"
          exit 1
        fi
        
        # Configurar chave privada
        echo "üîë Configurando chave privada SSH..."
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        # Verificar formato da chave
        if ! ssh-keygen -l -f ~/.ssh/id_rsa > /dev/null 2>&1; then
          echo "‚ùå ERRO: Formato da chave SSH inv√°lido!"
          echo "üí° Verifique se a chave est√° no formato correto (incluindo BEGIN e END lines)"
          exit 1
        fi
        
        echo "‚úÖ Chave SSH configurada com sucesso"
        
        # Configurar known_hosts
        echo "üîê Configurando known_hosts..."
        ssh-keyscan -H ${{ steps.infra.outputs.instance_ip }} >> ~/.ssh/known_hosts 2>/dev/null || {
          echo "‚ö†Ô∏è Aviso: N√£o foi poss√≠vel adicionar host key para ${{ steps.infra.outputs.instance_ip }}"
        }
                
        # Testar conex√£o SSH com mais detalhes
        echo "üîç Testando conex√£o SSH..."
        ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -v ubuntu@${{ steps.infra.outputs.instance_ip }} "echo 'SSH connection successful'" 2>&1 || {
          echo "‚ùå ERRO: Falha na conex√£o SSH"
          echo "üí° Poss√≠veis causas:"
          echo "   - Chave SSH incorreta"
          echo "   - Inst√¢ncia n√£o est√° pronta"
          echo "   - Security group n√£o permite SSH (porta 22)"
          echo "   - Usu√°rio 'ubuntu' n√£o existe na inst√¢ncia"
          echo "üîç Verificando se a porta 22 est√° aberta..."
          nc -z -w5 ${{ steps.infra.outputs.instance_ip }} 22 || echo "‚ùå Porta 22 n√£o est√° acess√≠vel"
          exit 1
        }
        
        echo "‚úÖ Conex√£o SSH estabelecida com sucesso!"

    - name: üê≥ Deploy Docker Application
      run: |
        echo "üöÄ Iniciando deploy da aplica√ß√£o..."
        
        # Comandos para deploy via SSH
        ssh ubuntu@${{ steps.infra.outputs.instance_ip }} << 'EOF'
          echo "üìÅ Navegando para diret√≥rio da aplica√ß√£o..."
          cd /opt/app/desafio-devops/backend
          
          echo "üîÑ Parando containers existentes..."
          docker compose -f docker-compose.prod.yml down || true
          
          echo "üßπ Limpando imagens antigas..."
          docker system prune -f
          
          echo "üì• Baixando nova imagem..."
          docker pull ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}
          
          echo "üöÄ Iniciando aplica√ß√£o..."
          docker compose -f docker-compose.prod.yml up -d
          
          echo "‚è≥ Aguardando aplica√ß√£o inicializar..."
          sleep 30
          
          echo "üîç Verificando status dos containers..."
          docker compose -f docker-compose.prod.yml ps
          
          echo "üìä Verificando logs da aplica√ß√£o..."
          docker compose -f docker-compose.prod.yml logs --tail=20
        EOF

  # ========================================
  # ETAPA 5: TESTES P√ìS-DEPLOY
  # ========================================
  post-deploy-tests:
    name: 'üß™ Post-Deploy Tests'
    runs-on: ubuntu-latest
    needs: deploy-application
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4

    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üèóÔ∏è Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: üöÄ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: üìä Get Instance IP
      working-directory: ./terraform
      id: infra
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT

    - name: üîç Health Check
      run: |
        echo "üîç Verificando health check da aplica√ß√£o..."
        
        # Aguardar aplica√ß√£o estar pronta
        for i in {1..30}; do
          echo "‚è≥ Tentativa $i/30 - Verificando health check..."
          if curl -f http://${{ steps.infra.outputs.instance_ip }}:3000/health > /dev/null 2>&1; then
            echo "‚úÖ Health check passou!"
            break
          fi
          sleep 10
        done
        
        # Teste final
        if ! curl -f http://${{ steps.infra.outputs.instance_ip }}:3000/health; then
          echo "‚ùå Health check falhou ap√≥s 30 tentativas"
          exit 1
        fi

    - name: üß™ API Tests
      run: |
        echo "üß™ Executando testes da API..."
        
        # Teste de cria√ß√£o de usu√°rio
        echo "üìù Testando cria√ß√£o de usu√°rio..."
        curl -X POST http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -H "Content-Type: application/json" \
          -d '{"name":"Test User","email":"test@example.com","password":"123456","age":25}' \
          -w "\nStatus: %{http_code}\n"
        
        # Teste de listagem de usu√°rios
        echo "üìã Testando listagem de usu√°rios..."
        curl -X GET http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -w "\nStatus: %{http_code}\n"
        
        # Teste de health check
        echo "üíö Testando health check..."
        curl -X GET http://${{ steps.infra.outputs.instance_ip }}:3000/health \
          -w "\nStatus: %{http_code}\n"

    - name: üîê Security Tests
      run: |
        echo "üîê Executando testes de seguran√ßa..."
        
        # Teste de headers de seguran√ßa
        echo "üõ°Ô∏è Verificando headers de seguran√ßa..."
        curl -I http://${{ steps.infra.outputs.instance_ip }}:3000/health
        
        # Teste de CORS
        echo "üåê Verificando CORS..."
        curl -H "Origin: https://malicious-site.com" \
          -H "Access-Control-Request-Method: POST" \
          -H "Access-Control-Request-Headers: Content-Type" \
          -X OPTIONS http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -v

  # ========================================
  # ETAPA 6: MONITORAMENTO E NOTIFICA√á√ÉO
  # ========================================
  monitoring:
    name: 'üìä Monitoring & Notification'
    runs-on: ubuntu-latest
    needs: [deploy-application, post-deploy-tests]
    if: always()
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4

    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üèóÔ∏è Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: üöÄ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: üìä Get Infrastructure Info
      working-directory: ./terraform
      id: infra
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT

    - name: üìà System Monitoring
      run: |
        echo "üìà Verificando m√©tricas do sistema..."
        
        # Verificar uso de CPU e mem√≥ria da inst√¢ncia
        aws cloudwatch get-metric-statistics \
          --namespace AWS/EC2 \
          --metric-name CPUUtilization \
          --dimensions Name=InstanceId,Value=${{ steps.infra.outputs.instance_id }} \
          --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \
          --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
          --period 300 \
          --statistics Average

    - name: üìã Deployment Summary
      run: |
        echo "üéâ DEPLOYMENT SUMMARY"
        echo "===================="
        echo "‚úÖ Application deployed successfully!"
        echo "üåê Public URL: http://${{ steps.infra.outputs.instance_ip }}:3000"
        echo "üÜî Instance ID: ${{ steps.infra.outputs.instance_id }}"
        echo "üê≥ Docker Image: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}"
        echo "üìÖ Deployed at: $(date)"
        echo "üîó Health Check: http://${{ steps.infra.outputs.instance_ip }}:3000/health"
        echo "üìä API Endpoints:"
        echo "   - GET /health"
        echo "   - GET /users"
        echo "   - POST /users"
        echo "   - GET /users/:id"
        echo "   - PUT /users/:id"
        echo "   - DELETE /users/:id"

    - name: üì¢ Success Notification
      if: success()
      run: |
        echo "üéâ DEPLOYMENT SUCCESSFUL!"
        echo "========================="
        echo "‚úÖ All tests passed"
        echo "‚úÖ Application is running"
        echo "‚úÖ Security checks passed"
        echo "üåê Access your application at: http://${{ steps.infra.outputs.instance_ip }}:3000"

    - name: üö® Failure Notification
      if: failure()
      run: |
        echo "‚ùå DEPLOYMENT FAILED!"
        echo "====================="
        echo "‚ùå One or more steps failed"
        echo "üîç Check the logs above for details"
        echo "üîÑ Manual intervention may be required" 