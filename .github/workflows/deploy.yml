name: ğŸš€ Application Deployment (CD)

on:
  workflow_run:
    workflows: ["Backend CI Pipeline", "Terraform CI/CD Pipeline"]
    types: [completed]
    branches: [main]

env:
  DOCKER_IMAGE_NAME: 1234samue/desafio-devops-api
  DOCKER_TAG: 0.0.1
  AWS_REGION: 'us-east-1'

jobs:
  # ========================================
  # ETAPA 1: VERIFICAÃ‡ÃƒO DE PRÃ‰-REQUISITOS
  # ========================================
  check-prerequisites:
    name: 'ğŸ” Check Prerequisites'
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: ğŸ“Š Get Infrastructure Info
      working-directory: ./terraform
      id: infra
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
        echo "security_group_id=$(terraform output -raw security_group_id)" >> $GITHUB_OUTPUT

    - name: ğŸ“‹ Display Infrastructure Info
      run: |
        echo "ğŸŒ Instance Public IP: ${{ steps.infra.outputs.instance_ip }}"
        echo "ğŸ†” Instance ID: ${{ steps.infra.outputs.instance_id }}"
        echo "ğŸ›¡ï¸ Security Group ID: ${{ steps.infra.outputs.security_group_id }}"

    - name: ğŸ” Verify Instance Status
      run: |
        echo "ğŸ” Verificando status da instÃ¢ncia..."
        aws ec2 describe-instances \
          --instance-ids ${{ steps.infra.outputs.instance_id }} \
          --query 'Reservations[0].Instances[0].State.Name' \
          --output text
        
        # Aguardar instÃ¢ncia estar running
        echo "â³ Aguardando instÃ¢ncia estar pronta..."
        aws ec2 wait instance-running --instance-ids ${{ steps.infra.outputs.instance_id }}
        echo "âœ… InstÃ¢ncia estÃ¡ running!"

  # ========================================
  # ETAPA 2: DEPLOY DA APLICAÃ‡ÃƒO
  # ========================================
  deploy-application:
    name: 'ğŸš€ Deploy Application'
    runs-on: ubuntu-latest
    needs: check-prerequisites
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: ğŸ“Š Get Instance IP
      working-directory: ./terraform
      id: infra
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT

    - name: ğŸ” Setup SSH Connection
      run: |
        # Criar diretÃ³rio .ssh
        mkdir -p ~/.ssh
        
        # Configurar chave privada
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        # Configurar known_hosts
        ssh-keyscan -H ${{ steps.infra.outputs.instance_ip }} >> ~/.ssh/known_hosts
        
        # Testar conexÃ£o SSH
        echo "ğŸ” Testando conexÃ£o SSH..."
        ssh -o ConnectTimeout=10 ubuntu@${{ steps.infra.outputs.instance_ip }} "echo 'SSH connection successful'"

    - name: ğŸ³ Deploy Docker Application
      run: |
        echo "ğŸš€ Iniciando deploy da aplicaÃ§Ã£o..."
        
        # Comandos para deploy via SSH
        ssh ubuntu@${{ steps.infra.outputs.instance_ip }} << 'EOF'
          echo "ğŸ“ Navegando para diretÃ³rio da aplicaÃ§Ã£o..."
          cd /opt/app/desafio-devops/backend
          
          echo "ğŸ”„ Parando containers existentes..."
          docker compose -f docker-compose.prod.yml down || true
          
          echo "ğŸ§¹ Limpando imagens antigas..."
          docker system prune -f
          
          echo "ğŸ“¥ Baixando nova imagem..."
          docker pull ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}
          
          echo "ğŸš€ Iniciando aplicaÃ§Ã£o..."
          docker compose -f docker-compose.prod.yml up -d
          
          echo "â³ Aguardando aplicaÃ§Ã£o inicializar..."
          sleep 30
          
          echo "ğŸ” Verificando status dos containers..."
          docker compose -f docker-compose.prod.yml ps
          
          echo "ğŸ“Š Verificando logs da aplicaÃ§Ã£o..."
          docker compose -f docker-compose.prod.yml logs --tail=20
        EOF

  # ========================================
  # ETAPA 3: TESTES PÃ“S-DEPLOY
  # ========================================
  post-deploy-tests:
    name: 'ğŸ§ª Post-Deploy Tests'
    runs-on: ubuntu-latest
    needs: deploy-application
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: ğŸ“Š Get Instance IP
      working-directory: ./terraform
      id: infra
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT

    - name: ğŸ” Health Check
      run: |
        echo "ğŸ” Verificando health check da aplicaÃ§Ã£o..."
        
        # Aguardar aplicaÃ§Ã£o estar pronta
        for i in {1..30}; do
          echo "â³ Tentativa $i/30 - Verificando health check..."
          if curl -f http://${{ steps.infra.outputs.instance_ip }}:3000/health > /dev/null 2>&1; then
            echo "âœ… Health check passou!"
            break
          fi
          sleep 10
        done
        
        # Teste final
        if ! curl -f http://${{ steps.infra.outputs.instance_ip }}:3000/health; then
          echo "âŒ Health check falhou apÃ³s 30 tentativas"
          exit 1
        fi

    - name: ğŸ§ª API Tests
      run: |
        echo "ğŸ§ª Executando testes da API..."
        
        # Teste de criaÃ§Ã£o de usuÃ¡rio
        echo "ğŸ“ Testando criaÃ§Ã£o de usuÃ¡rio..."
        curl -X POST http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -H "Content-Type: application/json" \
          -d '{"name":"Test User","email":"test@example.com","password":"123456","age":25}' \
          -w "\nStatus: %{http_code}\n"
        
        # Teste de listagem de usuÃ¡rios
        echo "ğŸ“‹ Testando listagem de usuÃ¡rios..."
        curl -X GET http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -w "\nStatus: %{http_code}\n"
        
        # Teste de health check
        echo "ğŸ’š Testando health check..."
        curl -X GET http://${{ steps.infra.outputs.instance_ip }}:3000/health \
          -w "\nStatus: %{http_code}\n"

    - name: ğŸ” Security Tests
      run: |
        echo "ğŸ” Executando testes de seguranÃ§a..."
        
        # Teste de headers de seguranÃ§a
        echo "ğŸ›¡ï¸ Verificando headers de seguranÃ§a..."
        curl -I http://${{ steps.infra.outputs.instance_ip }}:3000/health
        
        # Teste de CORS
        echo "ğŸŒ Verificando CORS..."
        curl -H "Origin: https://malicious-site.com" \
          -H "Access-Control-Request-Method: POST" \
          -H "Access-Control-Request-Headers: Content-Type" \
          -X OPTIONS http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -v

  # ========================================
  # ETAPA 4: MONITORAMENTO E NOTIFICAÃ‡ÃƒO
  # ========================================
  monitoring:
    name: 'ğŸ“Š Monitoring & Notification'
    runs-on: ubuntu-latest
    needs: [deploy-application, post-deploy-tests]
    if: always()
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: ğŸ“Š Get Infrastructure Info
      working-directory: ./terraform
      id: infra
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT

    - name: ğŸ“ˆ System Monitoring
      run: |
        echo "ğŸ“ˆ Verificando mÃ©tricas do sistema..."
        
        # Verificar uso de CPU e memÃ³ria da instÃ¢ncia
        aws cloudwatch get-metric-statistics \
          --namespace AWS/EC2 \
          --metric-name CPUUtilization \
          --dimensions Name=InstanceId,Value=${{ steps.infra.outputs.instance_id }} \
          --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \
          --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
          --period 300 \
          --statistics Average

    - name: ğŸ“‹ Deployment Summary
      run: |
        echo "ğŸ‰ DEPLOYMENT SUMMARY"
        echo "===================="
        echo "âœ… Application deployed successfully!"
        echo "ğŸŒ Public URL: http://${{ steps.infra.outputs.instance_ip }}:3000"
        echo "ğŸ†” Instance ID: ${{ steps.infra.outputs.instance_id }}"
        echo "ğŸ³ Docker Image: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}"
        echo "ğŸ“… Deployed at: $(date)"
        echo "ğŸ”— Health Check: http://${{ steps.infra.outputs.instance_ip }}:3000/health"
        echo "ğŸ“Š API Endpoints:"
        echo "   - GET /health"
        echo "   - GET /users"
        echo "   - POST /users"
        echo "   - GET /users/:id"
        echo "   - PUT /users/:id"
        echo "   - DELETE /users/:id"

    - name: ğŸ“¢ Success Notification
      if: success()
      run: |
        echo "ğŸ‰ DEPLOYMENT SUCCESSFUL!"
        echo "========================="
        echo "âœ… All tests passed"
        echo "âœ… Application is running"
        echo "âœ… Security checks passed"
        echo "ğŸŒ Access your application at: http://${{ steps.infra.outputs.instance_ip }}:3000"

    - name: ğŸš¨ Failure Notification
      if: failure()
      run: |
        echo "âŒ DEPLOYMENT FAILED!"
        echo "====================="
        echo "âŒ One or more steps failed"
        echo "ğŸ” Check the logs above for details"
        echo "ğŸ”„ Manual intervention may be required" 