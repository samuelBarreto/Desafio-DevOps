name: üöÄ Application Deployment (CD)


on:
  workflow_run:
    workflows: ["üê≥ Backend CI Pipeline", "üñ•Ô∏èTerraform CI/CD Pipeline"]
    types: [completed]
    branches: [main, develop]

  # Trigger manual para testes
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente para deploy'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - prod

env:
  DOCKER_IMAGE_NAME: 1234samue/desafio-devops-api
  AWS_REGION: 'us-east-1'

jobs:
  # ========================================
  # ETAPA 1: VERIFICA√á√ÉO DE PR√â-REQUISITOS
  # ========================================
  check-prerequisites:
    name: 'üîç Check Prerequisites'
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4

    - name: üìã Read Version and Set Docker Tag
      id: version
      run: |
        echo "üìã Reading version from VERSION file..."
        VERSION=$(cat VERSION | tr -d '[:space:]')
        echo "üì¶ Version read: $VERSION"
        echo "DOCKER_TAG=$VERSION" >> $GITHUB_ENV
        echo "docker_tag=$VERSION" >> $GITHUB_OUTPUT
        echo "‚úÖ DOCKER_TAG set to: $VERSION"

    - name: üîç Check Workflow Status
      if: github.event_name == 'workflow_run'
      run: |
        echo "üîç Verificando status do workflow que disparou o deploy..."
        echo "Workflow: ${{ github.event.workflow_run.name }}"
        echo "Status: ${{ github.event.workflow_run.conclusion }}"
        echo "Branch: ${{ github.event.workflow_run.head_branch }}"
        
        if [[ "${{ github.event.workflow_run.conclusion }}" != "success" ]]; then
          echo "‚ùå Workflow n√£o foi bem-sucedido. Deploy cancelado."
          exit 1
        fi
        
        echo "‚úÖ Workflow bem-sucedido. Continuando com o deploy..."

    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üèóÔ∏è Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'
  
    - name: üîç Detect Environment
      id: env
      run: |
          # Detectar ambiente baseado na branch que disparou o workflow ou input manual
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            echo "üåç Environment detected from manual input: $ENVIRONMENT"
          elif [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
            ENVIRONMENT="prod"
            echo "üåç Environment detected: PROD"
          else
            ENVIRONMENT="dev"
            echo "üåç Environment detected: DEV"
          fi
          
          # Definir NODE_ENV baseado no ambiente
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            NODE_ENV="production"
          else
            NODE_ENV="development"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "node_env=$NODE_ENV" >> $GITHUB_OUTPUT
          
          echo "üåç Environment: $ENVIRONMENT"
          echo "üîß NODE_ENV: $NODE_ENV"
          
          # Configurar backend para o ambiente detectado
          echo "üóÇÔ∏è Configurando backend para ambiente: $ENVIRONMENT"
          cd terraform
          sed -i "s|key     = \"terraform/environments/[^\"]*\"|key     = \"terraform/environments/$ENVIRONMENT/terraform.tfstate\"|g" backend.tf

    - name: üöÄ Terraform Init
      working-directory: ./terraform
      run: terraform init
    - name: üìä Get Infrastructure Info
      working-directory: ./terraform
      id: infra
      run: |
        echo "üîç Getting infrastructure info for ${{ steps.env.outputs.environment }} environment..."
        echo "instance_ip=$(terraform output -raw elastic_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
        echo "security_group_id=$(terraform output -raw security_group_id)" >> $GITHUB_OUTPUT

    - name: üìã Display Infrastructure Info
      run: |
        echo "üåç Environment: ${{ steps.env.outputs.environment }}"
        echo "üîß NODE_ENV: ${{ steps.env.outputs.node_env }}"
        echo "üåê Instance Public IP: ${{ steps.infra.outputs.instance_ip }}"
        echo "üÜî Instance ID: ${{ steps.infra.outputs.instance_id }}"
        echo "üõ°Ô∏è Security Group ID: ${{ steps.infra.outputs.security_group_id }}"

    - name: üîç Verify Instance Status
      run: |
        echo "üîç Verificando status da inst√¢ncia no ambiente ${{ steps.env.outputs.environment }}..."
        aws ec2 describe-instances \
          --instance-ids ${{ steps.infra.outputs.instance_id }} \
          --query 'Reservations[0].Instances[0].State.Name' \
          --output text
        
        # Aguardar inst√¢ncia estar running
        echo "‚è≥ Aguardando inst√¢ncia estar pronta..."
        aws ec2 wait instance-running --instance-ids ${{ steps.infra.outputs.instance_id }}
        echo "‚úÖ Inst√¢ncia est√° running!"

  # ========================================
  # ETAPA 2: DEPLOY DA APLICA√á√ÉO
  # ========================================
  deploy-application:
    name: 'üöÄ Deploy Application'
    runs-on: ubuntu-latest
    needs: check-prerequisites
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4

    - name: üìã Read Version and Set Docker Tag
      id: version
      run: |
        echo "üìã Reading version from VERSION file..."
        VERSION=$(cat VERSION | tr -d '[:space:]')
        echo "üì¶ Version read: $VERSION"
        echo "DOCKER_TAG=$VERSION" >> $GITHUB_ENV
        echo "docker_tag=$VERSION" >> $GITHUB_OUTPUT
        echo "‚úÖ DOCKER_TAG set to: $VERSION"

    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üèóÔ∏è Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'
    - name: üîç Detect Environment
      id: env
      run: |
          # Detectar ambiente baseado na branch que disparou o workflow ou input manual
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            echo "üåç Environment detected from manual input: $ENVIRONMENT"
          elif [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
            ENVIRONMENT="prod"
            echo "üåç Environment detected: PROD"
          else
            ENVIRONMENT="dev"
            echo "üåç Environment detected: DEV"
          fi
          
          # Definir NODE_ENV baseado no ambiente
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            NODE_ENV="production"
          else
            NODE_ENV="development"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "node_env=$NODE_ENV" >> $GITHUB_OUTPUT
          
          echo "üåç Environment: $ENVIRONMENT"
          echo "üîß NODE_ENV: $NODE_ENV"
          
          # Configurar backend para o ambiente detectado
          echo "üóÇÔ∏è Configurando backend para ambiente: $ENVIRONMENT"
          cd terraform
          sed -i "s|key     = \"terraform/environments/[^\"]*\"|key     = \"terraform/environments/$ENVIRONMENT/terraform.tfstate\"|g" backend.tf
    - name: üöÄ Terraform Init
      working-directory: ./terraform
      run: terraform init
    - name: üìä Set Instance IP
      id: infra
      working-directory: ./terraform
      run: |
        echo "üîç Definindo IP da inst√¢ncia para deploy no ambiente ${{ steps.env.outputs.environment }}..."
        INSTANCE_IP=$(terraform output -raw elastic_ip)
        echo "‚úÖ IP da inst√¢ncia definido: $INSTANCE_IP"
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: üîê Setup SSH Connection
      run: |
        echo "üîç Iniciando configura√ß√£o SSH..."
        
        # Criar diret√≥rio .ssh
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Verificar se o secret SSH_PRIVATE_KEY existe
        if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
          echo "‚ùå ERRO: SSH_PRIVATE_KEY secret n√£o est√° configurado!"
          echo "üí° Configure o secret SSH_PRIVATE_KEY no GitHub:"
          echo "   Settings > Secrets and variables > Actions > New repository secret"
          echo "   Name: SSH_PRIVATE_KEY"
          echo "   Value: Conte√∫do da sua chave privada SSH"
          exit 1
        fi
        
        # Configurar chave privada
        echo "üîë Configurando chave privada SSH..."
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        # Verificar formato da chave
        if ! ssh-keygen -l -f ~/.ssh/id_rsa > /dev/null 2>&1; then
          echo "‚ùå ERRO: Formato da chave SSH inv√°lido!"
          echo "üí° Verifique se a chave est√° no formato correto (incluindo BEGIN e END lines)"
          exit 1
        fi
        
        echo "‚úÖ Chave SSH configurada com sucesso"
        
        # Configurar known_hosts
        echo "üîê Configurando known_hosts..."
        ssh-keyscan -H ${{ steps.infra.outputs.instance_ip }} >> ~/.ssh/known_hosts 2>/dev/null || {
          echo "‚ö†Ô∏è Aviso: N√£o foi poss√≠vel adicionar host key para ${{ steps.infra.outputs.instance_ip }}"
        }
                
        # Testar conex√£o SSH com mais detalhes
        echo "üîç Testando conex√£o SSH..."
        ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -v ubuntu@${{ steps.infra.outputs.instance_ip }} "echo 'SSH connection successful'" 2>&1 || {
          echo "‚ùå ERRO: Falha na conex√£o SSH"
          echo "üí° Poss√≠veis causas:"
          echo "   - Chave SSH incorreta"
          echo "   - Inst√¢ncia n√£o est√° pronta"
          echo "   - Security group n√£o permite SSH (porta 22)"
          echo "   - Usu√°rio 'ubuntu' n√£o existe na inst√¢ncia"
          echo "üîç Verificando se a porta 22 est√° aberta..."
          nc -z -w5 ${{ steps.infra.outputs.instance_ip }} 22 || echo "‚ùå Porta 22 n√£o est√° acess√≠vel"
          exit 1
        }
        
        echo "‚úÖ Conex√£o SSH estabelecida com sucesso!"

    - name: üê≥ Deploy Docker Application
      run: |
        echo "üöÄ Iniciando deploy da aplica√ß√£o no ambiente ${{ steps.env.outputs.environment }}..."
        
        # Comandos para deploy via SSH
        ssh ubuntu@${{ steps.infra.outputs.instance_ip }} << EOF
          echo "üåç Environment: ${{ steps.env.outputs.environment }}"
          echo "üîß NODE_ENV: ${{ steps.env.outputs.node_env }}"
          echo "üìÅ Navegando para diret√≥rio da aplica√ß√£o..."
          cd /opt/app/desafio-devops
          git pull
          echo "‚úÖ Pull realizado com sucesso"


          cd /opt/app/desafio-devops/backend
          
          echo "üìù Atualizando docker-compose.prod.yml com vers√£o ${{ env.DOCKER_TAG }}..."
          
          # Backup do arquivo original
          cp docker-compose.prod.yml docker-compose.prod.yml.backup
          
          # Atualizar a imagem com a nova vers√£o
          sed -i "s|image:.*1234samue/desafio-devops-api:.*|image: docker.io/1234samue/desafio-devops-api:${{ env.DOCKER_TAG }}|g" docker-compose.prod.yml
          
          # Atualizar a vers√£o no environment
          sed -i "s|VERSION:.*|VERSION: ${{ env.DOCKER_TAG }}|g" docker-compose.prod.yml
          
          # Definir NODE_ENV baseado no ambiente detectado
          sed -i "s|NODE_ENV:.*|NODE_ENV: ${{ steps.env.outputs.node_env }}|g" docker-compose.prod.yml
          
          echo "‚úÖ docker-compose.prod.yml atualizado com vers√£o ${{ env.DOCKER_TAG }} e NODE_ENV: ${{ steps.env.outputs.node_env }}"
          
          echo "üîÑ Parando containers existentes..."
          docker compose -f docker-compose.prod.yml down || true
          
          echo "üßπ Limpando imagens antigas..."
          docker system prune -f
          
          echo "üì• Baixando nova imagem..."
          docker pull ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}
          
          echo "üöÄ Iniciando aplica√ß√£o..."
          docker compose -f docker-compose.prod.yml up -d
          
          echo "‚è≥ Aguardando aplica√ß√£o inicializar..."
          sleep 30
          
          echo "üîç Verificando status dos containers..."
          docker compose -f docker-compose.prod.yml ps
          
          echo "üìä Verificando logs da aplica√ß√£o..."
          docker compose -f docker-compose.prod.yml logs --tail=20
        EOF

  # ========================================
  # ETAPA 3: TESTES P√ìS-DEPLOY
  # ========================================
  post-deploy-tests:
    name: 'üß™ Post-Deploy Tests'
    runs-on: ubuntu-latest
    needs: deploy-application
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4

    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üèóÔ∏è Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'
    - name: üîç Detect Environment
      id: env
      run: |
          # Detectar ambiente baseado na branch que disparou o workflow ou input manual
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            echo "üåç Environment detected from manual input: $ENVIRONMENT"
          elif [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
            ENVIRONMENT="prod"
            echo "üåç Environment detected: PROD"
          else
            ENVIRONMENT="dev"
            echo "üåç Environment detected: DEV"
          fi
          
          # Definir NODE_ENV baseado no ambiente
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            NODE_ENV="production"
          else
            NODE_ENV="development"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "node_env=$NODE_ENV" >> $GITHUB_OUTPUT
          
          echo "üåç Environment: $ENVIRONMENT"
          echo "üîß NODE_ENV: $NODE_ENV"
          
          # Configurar backend para o ambiente detectado
          echo "üóÇÔ∏è Configurando backend para ambiente: $ENVIRONMENT"
          cd terraform
          sed -i "s|key     = \"terraform/environments/[^\"]*\"|key     = \"terraform/environments/$ENVIRONMENT/terraform.tfstate\"|g" backend.tf

    - name: üöÄ Terraform Init
      working-directory: ./terraform
      run: terraform init
    - name: üìä Set Instance IP for Tests
      id: infra
      working-directory: ./terraform
      run: |
        echo "üîç Definindo IP da inst√¢ncia para testes no ambiente ${{ steps.env.outputs.environment }}..."
        INSTANCE_IP=$(terraform output -raw elastic_ip)
        echo "‚úÖ IP da inst√¢ncia definido: $INSTANCE_IP"
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: üîç Health Check
      run: |
        echo "üîç Verificando health check da aplica√ß√£o no ambiente ${{ steps.env.outputs.environment }}..."
        
        # Aguardar aplica√ß√£o estar pronta
        for i in {1..30}; do
          echo "‚è≥ Tentativa $i/30 - Verificando health check..."
          if curl -f http://${{ steps.infra.outputs.instance_ip }}:3000/health > /dev/null 2>&1; then
            echo "‚úÖ Health check passou!"
            break
          fi
          sleep 10
        done
        
        # Teste final
        if ! curl -f http://${{ steps.infra.outputs.instance_ip }}:3000/health; then
          echo "‚ùå Health check falhou ap√≥s 30 tentativas"
          exit 1
        fi

    - name: üß™ API Tests
      run: |
        echo "üß™ Executando testes da API no ambiente ${{ steps.env.outputs.environment }}..."
        
        # Teste de cria√ß√£o de usu√°rio
        echo "üìù Testando cria√ß√£o de usu√°rio..."
        curl -X POST http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -H "Content-Type: application/json" \
          -d '{"name":"Test User","email":"test@example.com","password":"123456","age":25}' \
          -w "\nStatus: %{http_code}\n"
        
        # Teste de listagem de usu√°rios
        echo "üìã Testando listagem de usu√°rios..."
        curl -X GET http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -w "\nStatus: %{http_code}\n"
        
        # Teste de health check
        echo "üíö Testando health check..."
        curl -X GET http://${{ steps.infra.outputs.instance_ip }}:3000/health \
          -w "\nStatus: %{http_code}\n"

    - name: üîê Security Tests
      run: |
        echo "üîê Executando testes de seguran√ßa no ambiente ${{ steps.env.outputs.environment }}..."
        
        # Teste de headers de seguran√ßa
        echo "üõ°Ô∏è Verificando headers de seguran√ßa..."
        curl -I http://${{ steps.infra.outputs.instance_ip }}:3000/health
        
        # Teste de CORS
        echo "üåê Verificando CORS..."
        curl -H "Origin: https://malicious-site.com" \
          -H "Access-Control-Request-Method: POST" \
          -H "Access-Control-Request-Headers: Content-Type" \
          -X OPTIONS http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -v

  # ========================================
  # ETAPA 4: MONITORAMENTO E NOTIFICA√á√ÉO
  # ========================================
  monitoring:
    name: 'üìä Monitoring & Notification'
    runs-on: ubuntu-latest
    needs: [deploy-application, post-deploy-tests]
    if: always()
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v4

    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üèóÔ∏è Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'
    - name: üîç Detect Environment
      id: env
      run: |
          # Detectar ambiente baseado na branch que disparou o workflow ou input manual
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            echo "üåç Environment detected from manual input: $ENVIRONMENT"
          elif [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
            ENVIRONMENT="prod"
            echo "üåç Environment detected: PROD"
          else
            ENVIRONMENT="dev"
            echo "üåç Environment detected: DEV"
          fi
          
          # Definir NODE_ENV baseado no ambiente
          if [[ "$ENVIRONMENT" == "prod" ]]; then
            NODE_ENV="production"
          else
            NODE_ENV="development"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "node_env=$NODE_ENV" >> $GITHUB_OUTPUT
          
          echo "üåç Environment: $ENVIRONMENT"
          echo "üîß NODE_ENV: $NODE_ENV"
          
          # Configurar backend para o ambiente detectado
          echo "üóÇÔ∏è Configurando backend para ambiente: $ENVIRONMENT"
          cd terraform
          sed -i "s|key     = \"terraform/environments/[^\"]*\"|key     = \"terraform/environments/$ENVIRONMENT/terraform.tfstate\"|g" backend.tf
    - name: üöÄ Terraform Init
      working-directory: ./terraform
      run: terraform init
    - name: üìä Get Infrastructure Info
      working-directory: ./terraform
      id: infra
      run: |
        echo "üîç Getting infrastructure info for ${{ steps.env.outputs.environment }} environment..."
        echo "instance_ip=$(terraform output -raw elastic_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT

    - name: üìà System Monitoring
      run: |
        echo "üìà Verificando m√©tricas do sistema no ambiente ${{ steps.env.outputs.environment }}..."
        
        # Verificar uso de CPU e mem√≥ria da inst√¢ncia
        aws cloudwatch get-metric-statistics \
          --namespace AWS/EC2 \
          --metric-name CPUUtilization \
          --dimensions Name=InstanceId,Value=${{ steps.infra.outputs.instance_id }} \
          --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \
          --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
          --period 300 \
          --statistics Average

    - name: üìã Deployment Summary
      run: |
        echo "üéâ DEPLOYMENT SUMMARY"
        echo "===================="
        echo "üåç Environment: ${{ steps.env.outputs.environment }}"
        echo "üîß NODE_ENV: ${{ steps.env.outputs.node_env }}"
        echo "‚úÖ Application deployed successfully!"
        echo "üåê Public URL: http://${{ steps.infra.outputs.instance_ip }}:3000"
        echo "üÜî Instance ID: ${{ steps.infra.outputs.instance_id }}"
        echo "üê≥ Docker Image: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}"
        echo "üìÖ Deployed at: $(date)"
        echo "üîó Health Check: http://${{ steps.infra.outputs.instance_ip }}:3000/health"
        echo "üìä API Endpoints:"
        echo "   - GET /health"
        echo "   - GET /users"
        echo "   - POST /users"
        echo "   - GET /users/:id"
        echo "   - PUT /users/:id"
        echo "   - DELETE /users/:id"

    - name: üì¢ Success Notification
      if: success()
      run: |
        echo "üéâ DEPLOYMENT SUCCESSFUL!"
        echo "========================="
        echo "üåç Environment: ${{ steps.env.outputs.environment }}"
        echo "üîß NODE_ENV: ${{ steps.env.outputs.node_env }}"
        echo "‚úÖ All tests passed"
        echo "‚úÖ Application is running"
        echo "‚úÖ Security checks passed"
        echo "üåê Access your application at: http://${{ steps.infra.outputs.instance_ip }}:3000"

    - name: üö® Failure Notification
      if: failure()
      run: |
        echo "‚ùå DEPLOYMENT FAILED!"
        echo "====================="
        echo "üåç Environment: ${{ steps.env.outputs.environment }}"
        echo "üîß NODE_ENV: ${{ steps.env.outputs.node_env }}"
        echo "‚ùå One or more steps failed"
        echo "üîç Check the logs above for details"
        echo "üîÑ Manual intervention may be required"

    # ========================================
    # NOTIFICA√á√ïES DO SLACK
    # ========================================
    - name: üéâ Notificar Sucesso do Deploy
      if: success()
      uses: samuelBarreto/Action-Slack@main
      with:
        webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
        message: |
          üöÄ **Deploy Realizado com Sucesso!**
          
          **Ambiente:** ${{ steps.env.outputs.environment }}
          **Vers√£o:** ${{ env.DOCKER_TAG }}
          **URL:** http://${{ steps.infra.outputs.instance_ip }}:3000
          **Reposit√≥rio:** ${{ github.repository }}
          **Branch:** ${{ github.ref_name }}
          **Autor:** ${{ github.actor }}
          
          ‚úÖ Aplica√ß√£o est√° rodando e saud√°vel!
        channel: '#deployments'
        username: 'Deploy Bot'
        icon-emoji: ':rocket:'

    - name: ‚ùå Notificar Falha do Deploy
      if: failure()
      uses: samuelBarreto/Action-Slack@main
      with:
        webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
        message: |
          üö® **Deploy Falhou!**
          
          **Ambiente:** ${{ steps.env.outputs.environment }}
          **Vers√£o:** ${{ env.DOCKER_TAG }}
          **Reposit√≥rio:** ${{ github.repository }}
          **Branch:** ${{ github.ref_name }}
          **Autor:** ${{ github.actor }}
          
          ‚ùå Verifique os logs do workflow para mais detalhes.
          üîó [Ver Workflow](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
        channel: '#alerts'
        username: 'Deploy Bot'
        icon-emoji: ':warning:' 