name: ğŸš€ Application Deployment (CD)

on:
  workflow_run:
    workflows: ["Backend CI Pipeline", "Terraform CI/CD Pipeline"]
    types: [completed]
    branches: [main]

env:
  DOCKER_IMAGE_NAME: 1234samue/desafio-devops-api
  DOCKER_TAG: 0.0.1
  AWS_REGION: 'us-east-1'

jobs:
  # ========================================
  # ETAPA 1: VERIFICAR SE AMBOS OS WORKFLOWS TERMINARAM
  # ========================================
  check-workflows:
    name: 'ğŸ” Check Both Workflows Status'
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“‹ Check Deployment Lock
      id: check-lock
      run: |
        echo "ğŸ”’ Verificando se jÃ¡ hÃ¡ um deploy em andamento..."
        
        # Verificar se hÃ¡ algum run deste workflow em andamento
        CURRENT_RUN_ID="${{ github.run_id }}"
        RUNNING_DEPLOYS=$(gh run list --workflow="ğŸš€ Application Deployment (CD)" --status=in_progress --json id,status --jq '.[] | select(.id != '$CURRENT_RUN_ID') | .id' | wc -l)
        
        if [ "$RUNNING_DEPLOYS" -gt 0 ]; then
          echo "âš ï¸ JÃ¡ hÃ¡ um deploy em andamento. Aguardando..."
          echo "deploy_in_progress=true" >> $GITHUB_OUTPUT
        else
          echo "âœ… Nenhum deploy em andamento. Prosseguindo..."
          echo "deploy_in_progress=false" >> $GITHUB_OUTPUT
        fi

    - name: ğŸ“‹ Check Workflow Status
      id: check-status
      if: steps.check-lock.outputs.deploy_in_progress == 'false'
      run: |
        echo "ğŸ” Verificando status dos workflows..."
        
        # Obter informaÃ§Ãµes do workflow que acionou este pipeline
        TRIGGERING_WORKFLOW="${{ github.event.workflow.name }}"
        TRIGGERING_RUN_ID="${{ github.event.workflow_run.id }}"
        
        echo "ğŸ“‹ Workflow acionador: $TRIGGERING_WORKFLOW"
        echo "ğŸ†” Run ID: $TRIGGERING_RUN_ID"
        
        # Verificar se o workflow acionador foi bem-sucedido
        if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
          echo "âŒ Workflow acionador nÃ£o foi bem-sucedido: ${{ github.event.workflow_run.conclusion }}"
          exit 1
        fi
        
        echo "âœ… Workflow acionador foi bem-sucedido"
        
        # FunÃ§Ã£o para verificar se um workflow terminou com sucesso recentemente
        check_workflow_success() {
          local workflow_name="$1"
          local max_age_minutes=10  # Considerar apenas runs dos Ãºltimos 10 minutos
          
          echo "ğŸ” Verificando $workflow_name..."
          
          # Obter runs recentes do workflow
          local runs=$(gh run list --workflow="$workflow_name" --limit=10 --json conclusion,createdAt,id)
          
          # Verificar se hÃ¡ algum run bem-sucedido recente
          local success_run=$(echo "$runs" | jq -r '.[] | select(.conclusion == "success") | select((now - (.createdAt | fromdateiso8601)) < ('$max_age_minutes' * 60)) | .id' | head -1)
          
          if [ -n "$success_run" ] && [ "$success_run" != "null" ]; then
            echo "âœ… $workflow_name: Run $success_run foi bem-sucedido recentemente"
            return 0
          else
            echo "âŒ $workflow_name: Nenhum run bem-sucedido recente encontrado"
            return 1
          fi
        }
        
        # Verificar ambos os workflows
        BACKEND_SUCCESS=false
        TERRAFORM_SUCCESS=false
        
        if check_workflow_success "Backend CI Pipeline"; then
          BACKEND_SUCCESS=true
        fi
        
        if check_workflow_success "Terraform CI/CD Pipeline"; then
          TERRAFORM_SUCCESS=true
        fi
        
        echo "ğŸ“Š Status dos workflows:"
        echo "   Backend CI: $BACKEND_SUCCESS"
        echo "   Terraform: $TERRAFORM_SUCCESS"
        
        # Verificar se ambos terminaram com sucesso
        if [ "$BACKEND_SUCCESS" = true ] && [ "$TERRAFORM_SUCCESS" = true ]; then
          echo "âœ… Ambos os workflows terminaram com sucesso!"
          echo "ready=true" >> $GITHUB_OUTPUT
        else
          echo "â³ Aguardando ambos os workflows terminarem..."
          echo "   Backend CI: $BACKEND_SUCCESS"
          echo "   Terraform: $TERRAFORM_SUCCESS"
          echo "ready=false" >> $GITHUB_OUTPUT
        fi

  # ========================================
  # ETAPA 2: AGUARDAR DEPLOY ANTERIOR (SE NECESSÃRIO)
  # ========================================
  wait-for-deploy:
    name: 'â³ Wait for Previous Deploy'
    runs-on: ubuntu-latest
    needs: check-workflows
    if: needs.check-workflows.outputs.deploy_in_progress == 'true'
    
    steps:
    - name: ğŸ“‹ Wait for Deployment
      run: |
        echo "â³ Aguardando deploy anterior terminar..."
        echo "ğŸ” Verificando status a cada 30 segundos..."
        
        for i in {1..20}; do
          echo "â³ Tentativa $i/20 - Verificando se hÃ¡ deploy em andamento..."
          
          # Verificar se ainda hÃ¡ deploy em andamento
          RUNNING_DEPLOYS=$(gh run list --workflow="ğŸš€ Application Deployment (CD)" --status=in_progress --json id,status --jq '.[] | select(.id != '${{ github.run_id }}') | .id' | wc -l)
          
          if [ "$RUNNING_DEPLOYS" -eq 0 ]; then
            echo "âœ… Nenhum deploy em andamento. Prosseguindo..."
            break
          fi
          
          echo "â³ Ainda hÃ¡ $RUNNING_DEPLOYS deploy(s) em andamento. Aguardando 30s..."
          sleep 30
        done
        
        echo "âœ… Aguardamento concluÃ­do!"

  # ========================================
  # ETAPA 3: VERIFICAÃ‡ÃƒO DE PRÃ‰-REQUISITOS
  # ========================================
  check-prerequisites:
    name: 'ğŸ” Check Prerequisites'
    runs-on: ubuntu-latest
    needs: [check-workflows, wait-for-deploy]
    if: needs.check-workflows.outputs.ready == 'true' && (needs.check-workflows.outputs.deploy_in_progress == 'false' || needs.wait-for-deploy.result == 'success')
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: ğŸ“Š Get Infrastructure Info
      working-directory: ./terraform
      id: infra
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
        echo "security_group_id=$(terraform output -raw security_group_id)" >> $GITHUB_OUTPUT

    - name: ğŸ“‹ Display Infrastructure Info
      run: |
        echo "ğŸŒ Instance Public IP: ${{ steps.infra.outputs.instance_ip }}"
        echo "ğŸ†” Instance ID: ${{ steps.infra.outputs.instance_id }}"
        echo "ğŸ›¡ï¸ Security Group ID: ${{ steps.infra.outputs.security_group_id }}"

    - name: ğŸ” Verify Instance Status
      run: |
        echo "ğŸ” Verificando status da instÃ¢ncia..."
        aws ec2 describe-instances \
          --instance-ids ${{ steps.infra.outputs.instance_id }} \
          --query 'Reservations[0].Instances[0].State.Name' \
          --output text
        
        # Aguardar instÃ¢ncia estar running
        echo "â³ Aguardando instÃ¢ncia estar pronta..."
        aws ec2 wait instance-running --instance-ids ${{ steps.infra.outputs.instance_id }}
        echo "âœ… InstÃ¢ncia estÃ¡ running!"

  # ========================================
  # ETAPA 4: DEPLOY DA APLICAÃ‡ÃƒO
  # ========================================
  deploy-application:
    name: 'ğŸš€ Deploy Application'
    runs-on: ubuntu-latest
    needs: check-prerequisites
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: ğŸ“Š Get Instance IP
      working-directory: ./terraform
      id: infra
      run: |
        echo "ğŸ” Obtendo IP da instÃ¢ncia..."
        
        # Verificar se o Terraform estÃ¡ inicializado
        if [ ! -f ".terraform/terraform.tfstate" ]; then
          echo "âŒ ERRO: Terraform nÃ£o estÃ¡ inicializado!"
          exit 1
        fi
        
        # Tentar obter o IP da instÃ¢ncia
        INSTANCE_IP=$(terraform output -raw instance_public_ip 2>/dev/null) || {
          echo "âŒ ERRO: NÃ£o foi possÃ­vel obter o IP da instÃ¢ncia!"
          echo "ğŸ’¡ PossÃ­veis causas:"
          echo "   - Infraestrutura nÃ£o foi aplicada"
          echo "   - Output 'instance_public_ip' nÃ£o existe"
          echo "   - Estado do Terraform corrompido"
          echo ""
          echo "ğŸ” Verificando outputs disponÃ­veis..."
          terraform output || echo "âŒ Nenhum output disponÃ­vel"
          exit 1
        }
        
        # Validar se o IP nÃ£o estÃ¡ vazio
        if [ -z "$INSTANCE_IP" ]; then
          echo "âŒ ERRO: IP da instÃ¢ncia estÃ¡ vazio!"
          exit 1
        fi
        
        # Validar formato do IP
        if ! echo "$INSTANCE_IP" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' > /dev/null; then
          echo "âŒ ERRO: Formato de IP invÃ¡lido: $INSTANCE_IP"
          exit 1
        fi
        
        echo "âœ… IP da instÃ¢ncia obtido: $INSTANCE_IP"
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: ğŸ” Setup SSH Connection
      run: |
        echo "ğŸ” Iniciando configuraÃ§Ã£o SSH..."
        
        # Criar diretÃ³rio .ssh
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Verificar se o secret SSH_PRIVATE_KEY existe
        if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
          echo "âŒ ERRO: SSH_PRIVATE_KEY secret nÃ£o estÃ¡ configurado!"
          echo "ğŸ’¡ Configure o secret SSH_PRIVATE_KEY no GitHub:"
          echo "   Settings > Secrets and variables > Actions > New repository secret"
          echo "   Name: SSH_PRIVATE_KEY"
          echo "   Value: ConteÃºdo da sua chave privada SSH"
          exit 1
        fi
        
        # Configurar chave privada
        echo "ğŸ”‘ Configurando chave privada SSH..."
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        # Verificar formato da chave
        if ! ssh-keygen -l -f ~/.ssh/id_rsa > /dev/null 2>&1; then
          echo "âŒ ERRO: Formato da chave SSH invÃ¡lido!"
          echo "ğŸ’¡ Verifique se a chave estÃ¡ no formato correto (incluindo BEGIN e END lines)"
          exit 1
        fi
        
        echo "âœ… Chave SSH configurada com sucesso"
        
        # Configurar known_hosts
        echo "ğŸ” Configurando known_hosts..."
        ssh-keyscan -H ${{ steps.infra.outputs.instance_ip }} >> ~/.ssh/known_hosts 2>/dev/null || {
          echo "âš ï¸ Aviso: NÃ£o foi possÃ­vel adicionar host key para ${{ steps.infra.outputs.instance_ip }}"
        }
                
        # Testar conexÃ£o SSH com mais detalhes
        echo "ğŸ” Testando conexÃ£o SSH..."
        ssh -o ConnectTimeout=30 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -v ubuntu@${{ steps.infra.outputs.instance_ip }} "echo 'SSH connection successful'" 2>&1 || {
          echo "âŒ ERRO: Falha na conexÃ£o SSH"
          echo "ğŸ’¡ PossÃ­veis causas:"
          echo "   - Chave SSH incorreta"
          echo "   - InstÃ¢ncia nÃ£o estÃ¡ pronta"
          echo "   - Security group nÃ£o permite SSH (porta 22)"
          echo "   - UsuÃ¡rio 'ubuntu' nÃ£o existe na instÃ¢ncia"
          echo "ğŸ” Verificando se a porta 22 estÃ¡ aberta..."
          nc -z -w5 ${{ steps.infra.outputs.instance_ip }} 22 || echo "âŒ Porta 22 nÃ£o estÃ¡ acessÃ­vel"
          exit 1
        }
        
        echo "âœ… ConexÃ£o SSH estabelecida com sucesso!"

    - name: ğŸ³ Deploy Docker Application
      run: |
        echo "ğŸš€ Iniciando deploy da aplicaÃ§Ã£o..."
        
        # Comandos para deploy via SSH
        ssh ubuntu@${{ steps.infra.outputs.instance_ip }} << 'EOF'
          echo "ğŸ“ Navegando para diretÃ³rio da aplicaÃ§Ã£o..."
          cd /opt/app/desafio-devops/backend
          
          echo "ğŸ”„ Parando containers existentes..."
          docker compose -f docker-compose.prod.yml down || true
          
          echo "ğŸ§¹ Limpando imagens antigas..."
          docker system prune -f
          
          echo "ğŸ“¥ Baixando nova imagem..."
          docker pull ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}
          
          echo "ğŸš€ Iniciando aplicaÃ§Ã£o..."
          docker compose -f docker-compose.prod.yml up -d
          
          echo "â³ Aguardando aplicaÃ§Ã£o inicializar..."
          sleep 30
          
          echo "ğŸ” Verificando status dos containers..."
          docker compose -f docker-compose.prod.yml ps
          
          echo "ğŸ“Š Verificando logs da aplicaÃ§Ã£o..."
          docker compose -f docker-compose.prod.yml logs --tail=20
        EOF

  # ========================================
  # ETAPA 5: TESTES PÃ“S-DEPLOY
  # ========================================
  post-deploy-tests:
    name: 'ğŸ§ª Post-Deploy Tests'
    runs-on: ubuntu-latest
    needs: deploy-application
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: ğŸ“Š Get Instance IP
      working-directory: ./terraform
      id: infra
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT

    - name: ğŸ” Health Check
      run: |
        echo "ğŸ” Verificando health check da aplicaÃ§Ã£o..."
        
        # Aguardar aplicaÃ§Ã£o estar pronta
        for i in {1..30}; do
          echo "â³ Tentativa $i/30 - Verificando health check..."
          if curl -f http://${{ steps.infra.outputs.instance_ip }}:3000/health > /dev/null 2>&1; then
            echo "âœ… Health check passou!"
            break
          fi
          sleep 10
        done
        
        # Teste final
        if ! curl -f http://${{ steps.infra.outputs.instance_ip }}:3000/health; then
          echo "âŒ Health check falhou apÃ³s 30 tentativas"
          exit 1
        fi

    - name: ğŸ§ª API Tests
      run: |
        echo "ğŸ§ª Executando testes da API..."
        
        # Teste de criaÃ§Ã£o de usuÃ¡rio
        echo "ğŸ“ Testando criaÃ§Ã£o de usuÃ¡rio..."
        curl -X POST http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -H "Content-Type: application/json" \
          -d '{"name":"Test User","email":"test@example.com","password":"123456","age":25}' \
          -w "\nStatus: %{http_code}\n"
        
        # Teste de listagem de usuÃ¡rios
        echo "ğŸ“‹ Testando listagem de usuÃ¡rios..."
        curl -X GET http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -w "\nStatus: %{http_code}\n"
        
        # Teste de health check
        echo "ğŸ’š Testando health check..."
        curl -X GET http://${{ steps.infra.outputs.instance_ip }}:3000/health \
          -w "\nStatus: %{http_code}\n"

    - name: ğŸ” Security Tests
      run: |
        echo "ğŸ” Executando testes de seguranÃ§a..."
        
        # Teste de headers de seguranÃ§a
        echo "ğŸ›¡ï¸ Verificando headers de seguranÃ§a..."
        curl -I http://${{ steps.infra.outputs.instance_ip }}:3000/health
        
        # Teste de CORS
        echo "ğŸŒ Verificando CORS..."
        curl -H "Origin: https://malicious-site.com" \
          -H "Access-Control-Request-Method: POST" \
          -H "Access-Control-Request-Headers: Content-Type" \
          -X OPTIONS http://${{ steps.infra.outputs.instance_ip }}:3000/users \
          -v

  # ========================================
  # ETAPA 6: MONITORAMENTO E NOTIFICAÃ‡ÃƒO
  # ========================================
  monitoring:
    name: 'ğŸ“Š Monitoring & Notification'
    runs-on: ubuntu-latest
    needs: [deploy-application, post-deploy-tests]
    if: always()
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: ğŸ“Š Get Infrastructure Info
      working-directory: ./terraform
      id: infra
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT

    - name: ğŸ“ˆ System Monitoring
      run: |
        echo "ğŸ“ˆ Verificando mÃ©tricas do sistema..."
        
        # Verificar uso de CPU e memÃ³ria da instÃ¢ncia
        aws cloudwatch get-metric-statistics \
          --namespace AWS/EC2 \
          --metric-name CPUUtilization \
          --dimensions Name=InstanceId,Value=${{ steps.infra.outputs.instance_id }} \
          --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \
          --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
          --period 300 \
          --statistics Average

    - name: ğŸ“‹ Deployment Summary
      run: |
        echo "ğŸ‰ DEPLOYMENT SUMMARY"
        echo "===================="
        echo "âœ… Application deployed successfully!"
        echo "ğŸŒ Public URL: http://${{ steps.infra.outputs.instance_ip }}:3000"
        echo "ğŸ†” Instance ID: ${{ steps.infra.outputs.instance_id }}"
        echo "ğŸ³ Docker Image: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}"
        echo "ğŸ“… Deployed at: $(date)"
        echo "ğŸ”— Health Check: http://${{ steps.infra.outputs.instance_ip }}:3000/health"
        echo "ğŸ“Š API Endpoints:"
        echo "   - GET /health"
        echo "   - GET /users"
        echo "   - POST /users"
        echo "   - GET /users/:id"
        echo "   - PUT /users/:id"
        echo "   - DELETE /users/:id"

    - name: ğŸ“¢ Success Notification
      if: success()
      run: |
        echo "ğŸ‰ DEPLOYMENT SUCCESSFUL!"
        echo "========================="
        echo "âœ… All tests passed"
        echo "âœ… Application is running"
        echo "âœ… Security checks passed"
        echo "ğŸŒ Access your application at: http://${{ steps.infra.outputs.instance_ip }}:3000"

    - name: ğŸš¨ Failure Notification
      if: failure()
      run: |
        echo "âŒ DEPLOYMENT FAILED!"
        echo "====================="
        echo "âŒ One or more steps failed"
        echo "ğŸ” Check the logs above for details"
        echo "ğŸ”„ Manual intervention may be required" 