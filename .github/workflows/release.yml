name: ğŸš€ Release Pipeline

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (leave empty to use VERSION file)'
        required: false
        type: string

env:
  DOCKER_IMAGE_NAME: 1234samue/desafio-devops-api
  AWS_REGION: 'us-east-1'
  ENVIRONMENT: 'prod'  # Release sempre para produÃ§Ã£o

permissions:
  contents: write
  packages: write

jobs:
  # ========================================
  # ETAPA 1: VALIDAR E LER VERSÃƒO
  # ========================================
  validate-version:
    name: 'ğŸ” Validate Version'
    runs-on: ubuntu-latest
    
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      version-tag: ${{ steps.get-version.outputs.version-tag }}
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Read Version from File
      id: get-version
      run: |
        # Ler versÃ£o do arquivo VERSION ou usar input manual
        if [ -n "${{ github.event.inputs.version }}" ]; then
          VERSION="${{ github.event.inputs.version }}"
          echo "ğŸ“‹ Using manual version: $VERSION"
        else
          VERSION=$(cat VERSION | tr -d ' \t\n\r')
          echo "ğŸ“‹ Using version from file: $VERSION"
        fi
        
        # Validar formato da versÃ£o (semver)
        if [[ ! $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "âŒ Invalid version format. Expected: X.Y.Z (e.g., 1.0.0)"
          exit 1
        fi
        
        # Criar tag da versÃ£o
        VERSION_TAG="v$VERSION"
        
        echo "âœ… Version validated: $VERSION"
        echo "ğŸ·ï¸ Version tag: $VERSION_TAG"
        echo "ğŸŒ Environment: ${{ env.ENVIRONMENT }}"
        
        # Set outputs
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "version-tag=$VERSION_TAG" >> $GITHUB_OUTPUT

    - name: ğŸ“‹ Display Version Info
      run: |
        echo "ğŸ¯ RELEASE INFO"
        echo "==============="
        echo "Version: ${{ steps.get-version.outputs.version }}"
        echo "Version Tag: ${{ steps.get-version.outputs.version-tag }}"
        echo "Environment: ${{ env.ENVIRONMENT }}"
        echo "Docker Image: ${{ env.DOCKER_IMAGE_NAME }}:${{ steps.get-version.outputs.version }}"

  # ========================================
  # ETAPA 2: BUILD E PUSH DA IMAGEM
  # ========================================
  build-and-push:
    name: 'ğŸ³ Build and Push Docker Image'
    runs-on: ubuntu-latest
    needs: validate-version
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ—ï¸ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ğŸ”Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ vars.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: ğŸ“¦ Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_IMAGE_NAME }}
        tags: |
          type=raw,value=${{ needs.validate-version.outputs.version }}
          type=raw,value=${{ needs.validate-version.outputs.version-tag }}
          type=raw,value=latest
          type=sha

    - name: ğŸ“¦ Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VERSION=${{ needs.validate-version.outputs.version }}

    - name: ğŸ“‹ Display Image Info
      run: |
        echo "ğŸ³ DOCKER IMAGE INFO"
        echo "==================="
        echo "Image: ${{ env.DOCKER_IMAGE_NAME }}"
        echo "Version: ${{ needs.validate-version.outputs.version }}"
        echo "Environment: ${{ env.ENVIRONMENT }}"
        echo "Tags: ${{ steps.meta.outputs.tags }}"
        echo "Pushed successfully! ğŸš€"

  # ========================================
  # ETAPA 3: ATUALIZAR IMAGEM NA VM (PRODUÃ‡ÃƒO)
  # ========================================
  update-vm-image:
    name: 'ğŸ–¥ï¸ Update Image in VM (PRODUCTION)'
    runs-on: ubuntu-latest
    needs: [validate-version, build-and-push]
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ—ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.5.0'

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: ğŸ” Configure Production Environment
      id: env
      run: |
        echo "ğŸŒ Environment: ${{ env.ENVIRONMENT }}"
        echo "ğŸ­ This is a PRODUCTION release!"
        echo "environment=${{ env.ENVIRONMENT }}" >> $GITHUB_OUTPUT
        
        # Configurar backend para produÃ§Ã£o
        echo "ğŸ—‚ï¸ Configurando backend para ambiente: ${{ env.ENVIRONMENT }}"
        cd terraform
        
        # Backup do arquivo original
        cp backend.tf backend.tf.backup
        
        # Atualizar o backend para produÃ§Ã£o dinamicamente
        sed -i "s|key     = \"terraform/environments/dev/terraform.tfstate\"|key     = \"terraform/environments/${{ env.ENVIRONMENT }}/terraform.tfstate\"|g" backend.tf
        echo "âœ… Backend configurado para: terraform/environments/${{ env.ENVIRONMENT }}/terraform.tfstate"

    - name: ğŸ”„ Reinitialize Terraform with New Backend
      working-directory: ./terraform
      run: |
        echo "ğŸ”„ Reinitializando Terraform com nova configuraÃ§Ã£o de backend..."
        terraform init -reconfigure
        echo "âœ… Terraform reinitializado com sucesso"

    - name: ğŸ“Š Get Instance IP from Terraform
      working-directory: ./terraform
      id: infra
      run: |
        echo "ğŸ” Obtendo IP da instÃ¢ncia via Terraform (PRODUÃ‡ÃƒO)..."
        echo "ğŸŒ Environment: ${{ steps.env.outputs.environment }}"
        
        # Verificar se o state existe e tem recursos
        echo "ğŸ” Verificando estado do Terraform..."
        if ! terraform state list > /dev/null 2>&1; then
          echo "âŒ ERRO: Terraform state nÃ£o encontrado ou vazio!"
          echo "ğŸ’¡ Verificando se a infraestrutura estÃ¡ aplicada..."
          terraform show || echo "âŒ Terraform state nÃ£o encontrado"
          echo "ğŸ’¡ Verificando se hÃ¡ recursos no state..."
          terraform state list || echo "âŒ Nenhum recurso encontrado no state"
          exit 1
        fi
        
        # Verificar se hÃ¡ recursos no state
        RESOURCE_COUNT=$(terraform state list | wc -l)
        if [ "$RESOURCE_COUNT" -eq 0 ]; then
          echo "âŒ ERRO: State existe mas nÃ£o hÃ¡ recursos aplicados!"
          echo "ğŸ’¡ Execute 'terraform apply' primeiro para criar a infraestrutura"
          exit 1
        fi
        
        echo "âœ… State encontrado com $RESOURCE_COUNT recursos"
        
        # Obter o IP da instÃ¢ncia (Elastic IP) diretamente do state
        INSTANCE_IP=$(terraform output -raw elastic_ip 2>/dev/null) || {
          echo "âŒ ERRO: NÃ£o foi possÃ­vel obter o Elastic IP da instÃ¢ncia!"
          echo "ğŸ’¡ Verificando outputs disponÃ­veis..."
          terraform output || echo "âŒ Nenhum output encontrado"
          echo "ğŸ’¡ Verificando se o recurso elastic_ip existe..."
          terraform state list | grep -i elastic || echo "âŒ Recurso elastic_ip nÃ£o encontrado"
          exit 1
        }
        
        # Validar se o IP nÃ£o estÃ¡ vazio
        if [ -z "$INSTANCE_IP" ]; then
          echo "âŒ ERRO: IP da instÃ¢ncia estÃ¡ vazio!"
          exit 1
        fi
        
        # Validar formato do IP
        if ! echo "$INSTANCE_IP" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' > /dev/null; then
          echo "âŒ ERRO: Formato de IP invÃ¡lido: $INSTANCE_IP"
          exit 1
        fi
        
        echo "âœ… Elastic IP da instÃ¢ncia obtido via Terraform: $INSTANCE_IP"
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: ğŸ” Setup SSH Connection
      run: |
        echo "ğŸ” Configurando SSH para ambiente PRODUÃ‡ÃƒO..."
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ steps.infra.outputs.instance_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
        echo "âœ… SSH configurado para ${{ steps.infra.outputs.instance_ip }}"

    - name: ğŸ”„ Update Image in VM
      run: |
        echo "ğŸ”„ Atualizando imagem na VM de PRODUÃ‡ÃƒO..."
        echo "ğŸŒ Environment: PRODUCTION"
        echo "ğŸ”§ NODE_ENV: production"
        echo "ğŸŒ Instance IP: ${{ steps.infra.outputs.instance_ip }}"
        echo "ğŸ³ New Image: ${{ env.DOCKER_IMAGE_NAME }}:${{ needs.validate-version.outputs.version }}"
        
        ssh ubuntu@${{ steps.infra.outputs.instance_ip }} << EOF
          echo "ğŸŒ Environment: PRODUCTION"
          echo "ğŸ”§ NODE_ENV: production"
          echo "ğŸ“ Navegando para diretÃ³rio da aplicaÃ§Ã£o..."
          cd /opt/app/desafio-devops/backend

          git pull
          echo "âœ… Pull realizado com sucesso"
          
          echo "ğŸ“ Atualizando docker-compose.prod.yml com nova versÃ£o..."
          
          # Backup do arquivo original
          cp docker-compose.prod.yml docker-compose.prod.yml.backup
          
          # Atualizar a imagem com a nova versÃ£o
          sed -i "s|image:.*1234samue/desafio-devops-api:.*|image: docker.io/1234samue/desafio-devops-api:${{ needs.validate-version.outputs.version }}|g" docker-compose.prod.yml
          
          # Atualizar a versÃ£o no environment
          sed -i "s|VERSION:.*|VERSION: ${{ needs.validate-version.outputs.version }}|g" docker-compose.prod.yml
          
          # Garantir que NODE_ENV estÃ¡ como production (release sempre para produÃ§Ã£o)
          sed -i "s|NODE_ENV:.*|NODE_ENV: production|g" docker-compose.prod.yml
          
          echo "âœ… docker-compose.prod.yml atualizado com versÃ£o ${{ needs.validate-version.outputs.version }} e NODE_ENV: production"
          
          echo "ğŸ”„ Parando containers existentes..."
          docker compose -f docker-compose.prod.yml down || true
          
          echo "ğŸ“¥ Baixando nova imagem..."
          docker pull ${{ env.DOCKER_IMAGE_NAME }}:${{ needs.validate-version.outputs.version }}
          
          echo "ğŸš€ Iniciando aplicaÃ§Ã£o com nova versÃ£o..."
          docker compose -f docker-compose.prod.yml up -d
          
          echo "â³ Aguardando aplicaÃ§Ã£o inicializar..."
          sleep 30
          
          echo "ğŸ” Verificando status dos containers..."
          docker compose -f docker-compose.prod.yml ps
          
          echo "ğŸ“Š Verificando logs da aplicaÃ§Ã£o..."
          docker compose -f docker-compose.prod.yml logs --tail=20
        EOF

  # ========================================
  # ETAPA 4: CRIAR GIT TAG E RELEASE
  # ========================================
  create-release:
    name: 'ğŸ·ï¸ Create Git Tag and Release'
    runs-on: ubuntu-latest
    needs: [validate-version, build-and-push, update-vm-image]
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ” Configure Git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"

    - name: ğŸ·ï¸ Create Git Tag
      run: |
        echo "ğŸ·ï¸ Creating git tag: ${{ needs.validate-version.outputs.version-tag }}"
        git tag -a "${{ needs.validate-version.outputs.version-tag }}" -m "Release version ${{ needs.validate-version.outputs.version }}"
        echo "âœ… Git tag created locally"

    - name: ğŸš€ Push Git Tag
      run: |
        echo "ğŸš€ Pushing git tag to remote..."
        git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}
        git push origin "${{ needs.validate-version.outputs.version-tag }}"
        echo "âœ… Git tag pushed successfully"

    - name: ğŸ§¹ Restore Original Backend Configuration
      working-directory: ./terraform
      if: always()
      run: |
        echo "ğŸ§¹ Restaurando configuraÃ§Ã£o original do backend..."
        if [ -f backend.tf.backup ]; then
          mv backend.tf.backup backend.tf
          echo "âœ… Backend configuration restored"
        else
          echo "âš ï¸ Backup file not found, skipping restore"
        fi

    - name: ğŸ“‹ Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ needs.validate-version.outputs.version-tag }}
        release_name: Release ${{ needs.validate-version.outputs.version }}
        body: |
          ğŸš€ Release Version ${{ needs.validate-version.outputs.version }}
          
          ## ğŸŒ Environment
          - **Environment**: PRODUCTION
          - **Deployed to**: Production VM
          
          ## ğŸ“¦ Docker Image
          - **Image**: `${{ env.DOCKER_IMAGE_NAME }}:${{ needs.validate-version.outputs.version }}`
          - **Tag**: `${{ needs.validate-version.outputs.version-tag }}`
          
          ## ğŸš€ Deploy
          - âœ… Docker image built and pushed
          - âœ… Production VM updated with new image
          - âœ… Application deployed successfully to PRODUCTION
          
          ## ğŸ“Š API Endpoints
          - Health Check: `/health`
          - Users: `/users`
          
          ## ğŸ”— Links
          - Docker Hub: https://hub.docker.com/r/${{ env.DOCKER_IMAGE_NAME }}
        draft: false
        prerelease: false

    - name: ğŸ“‹ Display Release Summary
      run: |
        echo "ğŸ‰ RELEASE SUMMARY"
        echo "=================="
        echo "ğŸŒ Environment: PRODUCTION"
        echo "âœ… Version: ${{ needs.validate-version.outputs.version }}"
        echo "âœ… Tag: ${{ needs.validate-version.outputs.version-tag }}"
        echo "âœ… Docker Image: ${{ env.DOCKER_IMAGE_NAME }}:${{ needs.validate-version.outputs.version }}"
        echo "âœ… Production VM updated with new image"
        echo "âœ… Git tag created"
        echo "âœ… GitHub release created"
        echo ""
        echo "ğŸ¯ Release completed successfully to PRODUCTION!" 